/**
 * Tests for AIProviderWorker
 */

import { AIProviderWorker } from '../../src/workers/AIProviderWorker';
import type { AIProviderConfig } from '../../src/core/types';

describe('AIProviderWorker', () => {
  let provider: AIProviderWorker;
  let config: AIProviderConfig;

  beforeEach(() => {
    config = {
      llm: {
        model: 'test-model',
        dtype: 'q4',
      },
    };

    // Mock WorkerPool
    jest.mock('./WorkerPool', () => ({
      WorkerPool: jest.fn().mockImplementation(() => ({
        execute: jest.fn().mockResolvedValue({
          content: 'Mock response',
          role: 'assistant',
        }),
        terminate: jest.fn(),
        getStats: jest.fn().mockReturnValue({
          total: 2,
          available: 1,
          busy: 1,
          queued: 0,
          active: 1,
        }),
      })),
    }));

    provider = new AIProviderWorker(config);
  });

  afterEach(async () => {
    await provider.dispose();
  });

  describe('Initialization', () => {
    it('should create provider with config', () => {
      expect(provider).toBeInstanceOf(AIProviderWorker);
      expect(provider.getConfig()).toEqual(config);
    });

    it('should create provider without config', () => {
      const emptyProvider = new AIProviderWorker();
      expect(emptyProvider.getConfig()).toEqual({});
    });
  });

  describe('LLM Methods', () => {
    it('should throw error if LLM not configured', async () => {
      const noLLMProvider = new AIProviderWorker({});
      await expect(noLLMProvider.chat('hello')).rejects.toThrow(
        'LLM not configured'
      );
    });

    it('should chat with string message', async () => {
      const response = await provider.chat('Hello');
      expect(response).toHaveProperty('content');
      expect(response.content).toBe('Mock response');
      expect(response.role).toBe('assistant');
    });

    it('should complete prompt', async () => {
      const result = await provider.complete('Test prompt');
      expect(typeof result).toBe('string');
    });
  });

  describe('Lifecycle', () => {
    it('should warmup model', async () => {
      await expect(provider.warmup()).resolves.not.toThrow();
      expect(provider.isReady()).toBe(true);
    });

    it('should unload model', async () => {
      await provider.warmup();
      await expect(provider.unload()).resolves.not.toThrow();
    });

    it('should check if ready', () => {
      expect(provider.isReady()).toBe(false);
    });

    it('should dispose provider', async () => {
      await expect(provider.dispose()).resolves.not.toThrow();
    });
  });

  describe('Event System', () => {
    it('should register event listeners', () => {
      const mockCallback = jest.fn();
      provider.on('ready', mockCallback);
      provider.once('error', mockCallback);
    });

    it('should remove event listeners', () => {
      const mockCallback = jest.fn();
      provider.on('progress', mockCallback);
      provider.off('progress', mockCallback);
    });
  });

  describe('Worker Pool', () => {
    it('should return worker pool stats', () => {
      const stats = provider.getStats();
      expect(stats).toHaveProperty('total');
      expect(stats).toHaveProperty('available');
      expect(stats).toHaveProperty('busy');
      expect(stats?.total).toBe(2);
    });
  });

  describe('Error Handling', () => {
    it('should handle model loading errors', async () => {
      // Mock WorkerPool to throw error
      const mockWorkerPool = {
        execute: jest.fn().mockRejectedValue(new Error('Load failed')),
        terminate: jest.fn(),
        getStats: jest.fn().mockReturnValue(null),
      };

      // Replace the internal worker pool
      (provider as any).workerPool = mockWorkerPool;

      await expect(provider.warmup()).rejects.toThrow('Load failed');
    });

    it('should handle chat errors', async () => {
      const mockWorkerPool = {
        execute: jest.fn().mockRejectedValue(new Error('Chat failed')),
        terminate: jest.fn(),
        getStats: jest.fn().mockReturnValue(null),
      };

      (provider as any).workerPool = mockWorkerPool;

      await expect(provider.chat('test')).rejects.toThrow('Chat failed');
    });
  });
});

